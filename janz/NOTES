developer notes
===============

uses of (struct janz_skb *cb) fields
------------------------------------

fields:
- ts_enq
- [	pktxlatency	| qdelay1024			]
- srcport
- dstport
- [	tosbyte		| { xqid, xmitnum, xmittot }	]
- ipver
- nexthdr
- record_flag

janz_record_packet:
- ts_enq
- srcport
- dstport
- xqid
- ipver
- nexthdr
- record_flag

janz_drop_pkt:
  qdelay_encode:
  - ts_enq
  - pktxlatency
- xqid
- record_flag
⇒ janz_record_packet

janz_sendoff:
  qdelay_encode:
  - ts_enq
  - pktxlatency
- xqid
- record_flag
⇒ janz_record_packet

janz_init_record_flag:
- tosbyte
- record_flag

janz_analyse:
- ts_enq
- srcport
- dstport
- tosbyte
- ipver
- nexthdr

data to put on ice for retransmissions
--------------------------------------

- skb
- u64 now (time of FIRST transmission)
  ⇒ skb->dev_scratch (ulong!) if we reset “skb->dev = qdisc_dev(sch);” before handing out
- ts_enq
- qdelay1024
- srcport
- dstport
- xqid (2 bits)
- # of transmissions to do (3 bits)
- # of transmissions already done (3 bits)
- ipver
- nexthdr
- record_flag

vs data we do NOT need any more
- pktxlatency (already overlaid by qdelay1024)
- tosbyte (already overlaid by { xqid, xmitnum, xmittot })

other
-----

Document that:
• the bypass is now implemented, and what is sent there
• sch_multijens: the bypass is loosely attached to UE#0
  but w̲i̲l̲l̲ ignore capacity there
